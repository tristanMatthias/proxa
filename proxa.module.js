const e=Symbol("proxa"),t=Symbol("proxaUpdate"),o=Symbol("proxaCallbacks"),r=Symbol("proxaPropCallbacks"),l=Symbol("proxaParent"),a=Symbol("proxaIsArray"),n=[e,t,o,r,l,a,"toJSON"],s=(c,i,b,p)=>{let u;const d={get(t,o){if(n.includes(o))return t[o];const r=t[o];return void 0!==r?null===r?null:(r[e]||"object"!=typeof r||(t[o]=s(r,void 0,void 0,u)),t[o]):void 0},set:(e,o,r)=>e[o]==r||(e[o]=r,n.includes(o)||e[t](o,r),!0)};if(c[e]?u=c:((u=new Proxy(c,d))[e]=!0,u[o]=[],u[r]=new Map,u[t]=(e,a)=>{u[o].forEach(t=>t(u,e,a));const n=u[r].get(e);n&&n.forEach(t=>t(u,e,a)),u[l]&&u[l][t]()},p&&(u[l]=p),c instanceof Array&&(u[a]=!0),Object.defineProperty(u,"toJSON",{enumerable:!1,writable:!1,value:()=>{let t=Object.assign({},u);return n.forEach(e=>delete t[e]),Object.entries(t).forEach(([o,r])=>{r&&"object"==typeof r&&r[e]&&(t[o]=r.toJSON())}),u[a]?Object.entries(t).reduce((e,[t,o])=>(/^\d+$/.test(t)&&e.push(o),e),[]):(delete t.toJSON,t)}})),i)if(b||u[o].includes(i)){if(b){let e=u[r].get(b);e||(e=[],u[r].set(b,e)),e.push(i)}}else u[o].push(i);return u};export{s as proxa};
