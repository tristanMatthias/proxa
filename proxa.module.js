const e=Symbol("proxa"),t=Symbol("proxaUpdate"),o=Symbol("proxaCallbacks"),r=Symbol("proxaPropCallbacks"),a=Symbol("proxaParent"),l=Symbol("proxaIsArray"),s=[e,t,o,r,a,l,"toJSON"],c=(n,b,p,i)=>{let u;const f={get(t,o){if(s.includes(o))return t[o];const r=t[o];return r&&!r[e]&&"object"==typeof r&&(t[o]=c(r,void 0,void 0,u)),t[o]},set:(e,o,r)=>e[o]==r||(e[o]=r,s.includes(o)||e[t](o,r),!0)};if(n[e]?u=n:((u=new Proxy(n,f))[e]=!0,u[o]=[],u[r]=new Map,u[t]=(e,l)=>{u[o].forEach(t=>t(u,e,l));const s=u[r].get(e);s&&s.forEach(t=>t(u,e,l)),u[a]&&u[a][t]()},i&&(u[a]=i),n instanceof Array&&(u[l]=!0),Object.defineProperty(u,"toJSON",{enumerable:!1,writable:!1,value:()=>{let t=Object.assign({},u);return s.forEach(e=>delete t[e]),Object.entries(t).forEach(([o,r])=>{r&&"object"==typeof r&&r[e]&&(t[o]=r.toJSON())}),u[l]?Object.entries(t).reduce((e,[t,o])=>(/^\d+$/.test(t)&&e.push(o),e),[]):(delete t.toJSON,t)}})),b)if(p||u[o].includes(b)){if(p){let e=u[r].get(p);e||(e=[],u[r].set(p,e)),e.push(b)}}else u[o].push(b);return u};export{c as proxa};
