const e=Symbol("proxa"),o=Symbol("proxaUpdate"),t=Symbol("proxaCallbacks"),r=Symbol("proxaPropCallbacks"),n=Symbol("proxaParent"),s=Symbol("proxaIsArray"),c=(e,o,n)=>{const s=e;if(console.log(s[t]),n){const e=s[r].get(n);if(!e)throw new Error(`Could not find any callbacks for property '${n}'`);const t=e.indexOf(o);if(t<0)throw new Error(`Callback does not exist on property '${n}' for this object`);e.splice(t,1)}else{const e=s[t].indexOf(o);if(console.log(e),e<0)throw new Error("Callback does not exist on this object");s[t].splice(e,1)}return e},l=[e,o,t,r,n,s,"toJSON"],a=(c,i,p,b)=>{let f;const d={get(o,t){if(l.includes(t))return o[t];const r=o[t];return r&&!r[e]&&"object"==typeof r&&(o[t]=a(r,void 0,void 0,f)),o[t]},set:(e,t,r)=>e[t]===r||(e[t]=r,l.includes(t)||e[o](t,r),!0)};if(c[e]?f=c:((f=new Proxy(c,d))[e]=!0,f[t]=[],f[r]=new Map,f[o]=(e,s)=>{f[t].forEach(o=>o(f,e,s));const c=f[r].get(e);c&&c.forEach(o=>o(f,e,s)),f[n]&&f[n][o]()},b&&(f[n]=b),c instanceof Array&&(f[s]=!0),Object.defineProperty(f,"toJSON",{enumerable:!1,writable:!1,value:()=>{const o=Object.assign({},f);return l.forEach(e=>delete o[e]),Object.entries(o).forEach(([t,r])=>{r&&"object"==typeof r&&r[e]&&(o[t]=r.toJSON())}),f[s]?Object.entries(o).reduce((e,[o,t])=>(/^\d+$/.test(o)&&e.push(t),e),[]):(delete o.toJSON,o)}})),i)if(p||f[t].includes(i)){if(p){let e=f[r].get(p);e||(e=[],f[r].set(p,e)),e.push(i)}}else f[t].push(i);return f};export{c as off,a as proxa};
